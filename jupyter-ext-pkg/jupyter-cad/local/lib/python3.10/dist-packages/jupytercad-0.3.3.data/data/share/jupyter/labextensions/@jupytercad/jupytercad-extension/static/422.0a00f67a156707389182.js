"use strict";(self.webpackChunk_jupytercad_jupytercad_extension=self.webpackChunk_jupytercad_jupytercad_extension||[]).push([[422],{1422:(t,e,n)=>{n.r(e),n.d(e,{AVERAGE:()=>i,CENTER:()=>r,CONTAINED:()=>u,ExtendedTriangle:()=>z,FloatVertexAttributeTexture:()=>ee,INTERSECTED:()=>c,IntVertexAttributeTexture:()=>te,MeshBVH:()=>Nt,MeshBVHUniformStruct:()=>ne,MeshBVHVisualizer:()=>_t,NOT_INTERSECTED:()=>a,OrientedBox:()=>N,SAH:()=>s,StaticGeometryGenerator:()=>Te,UIntVertexAttributeTexture:()=>Qt,VertexAttributeTexture:()=>Kt,acceleratedRaycast:()=>jt,computeBoundsTree:()=>Zt,disposeBoundsTree:()=>$t,estimateMemoryInBytes:()=>Gt,getBVHExtremes:()=>Ct,getJSONStructure:()=>Lt,getTriangleHitPointInfo:()=>J,shaderDistanceFunction:()=>ie,shaderIntersectFunction:()=>re,shaderStructs:()=>oe,validateBounds:()=>Ot});var o=n(3391);const r=0,i=1,s=2,a=0,c=1,u=2,l=1.25,d=1,f=32,h=65535,p=Math.pow(2,-24);class m{constructor(){}}function y(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function x(t){let e=-1,n=-1/0;for(let o=0;o<3;o++){const r=t[o+3]-t[o];r>n&&(n=r,e=o)}return e}function g(t,e){e.set(t)}function b(t,e,n){let o,r;for(let i=0;i<3;i++){const s=i+3;o=t[i],r=e[i],n[i]=o<r?o:r,o=t[s],r=e[s],n[s]=o>r?o:r}}function v(t,e,n){for(let o=0;o<3;o++){const r=e[t+2*o],i=e[t+2*o+1],s=r-i,a=r+i;s<n[o]&&(n[o]=s),a>n[o+3]&&(n[o+3]=a)}}function w(t){const e=t[3]-t[0],n=t[4]-t[1],o=t[5]-t[2];return 2*(e*n+n*o+o*e)}function B(t,e,n,o,r=null){let i=1/0,s=1/0,a=1/0,c=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,h=1/0,p=-1/0,m=-1/0,y=-1/0;const x=null!==r;for(let o=6*e,r=6*(e+n);o<r;o+=6){const e=t[o+0],n=t[o+1],r=e-n,g=e+n;r<i&&(i=r),g>c&&(c=g),x&&e<d&&(d=e),x&&e>p&&(p=e);const b=t[o+2],v=t[o+3],w=b-v,B=b+v;w<s&&(s=w),B>u&&(u=B),x&&b<f&&(f=b),x&&b>m&&(m=b);const T=t[o+4],A=t[o+5],M=T-A,I=T+A;M<a&&(a=M),I>l&&(l=I),x&&T<h&&(h=T),x&&T>y&&(y=T)}o[0]=i,o[1]=s,o[2]=a,o[3]=c,o[4]=u,o[5]=l,x&&(r[0]=d,r[1]=f,r[2]=h,r[3]=p,r[4]=m,r[5]=y)}const T=32,A=(t,e)=>t.candidate-e.candidate,M=new Array(T).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),I=new Float32Array(6);class P{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,o=-1/0;for(let r=0,i=t.length;r<i;r++){const i=t[r][e];n=i<n?i:n,o=i>o?i:o}this.min=n,this.max=o}setFromPoints(t,e){let n=1/0,o=-1/0;for(let r=0,i=e.length;r<i;r++){const i=e[r],s=t.dot(i);n=s<n?s:n,o=s>o?s:o}this.min=n,this.max=o}isSeparated(t){return this.min>t.max||t.min>this.max}}P.prototype.setFromBox=function(){const t=new o.Vector3;return function(e,n){const o=n.min,r=n.max;let i=1/0,s=-1/0;for(let n=0;n<=1;n++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){t.x=o.x*n+r.x*(1-n),t.y=o.y*a+r.y*(1-a),t.z=o.z*c+r.z*(1-c);const u=e.dot(t);i=Math.min(u,i),s=Math.max(u,s)}this.min=i,this.max=s}}(),new P;const S=function(){const t=new o.Vector3,e=new o.Vector3,n=new o.Vector3;return function(o,r,i){const s=o.start,a=t,c=r.start,u=e;n.subVectors(s,c),t.subVectors(o.end,o.start),e.subVectors(r.end,r.start);const l=n.dot(u),d=u.dot(a),f=u.dot(u),h=n.dot(a),p=a.dot(a)*f-d*d;let m,y;m=0!==p?(l*d-h*f)/p:0,y=(l+m*d)/f,i.x=m,i.y=y}}(),F=function(){const t=new o.Vector2,e=new o.Vector3,n=new o.Vector3;return function(o,r,i,s){S(o,r,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return o.at(a,i),void r.at(c,s);if(a>=0&&a<=1)return c<0?r.at(0,s):r.at(1,s),void o.closestPointToPoint(s,!0,i);if(c>=0&&c<=1)return a<0?o.at(0,i):o.at(1,i),void r.closestPointToPoint(i,!0,s);{let t,u;t=a<0?o.start:o.end,u=c<0?r.start:r.end;const l=e,d=n;return o.closestPointToPoint(u,!0,e),r.closestPointToPoint(t,!0,n),l.distanceToSquared(u)<=d.distanceToSquared(t)?(i.copy(l),void s.copy(u)):(i.copy(t),void s.copy(d))}}}(),V=function(){const t=new o.Vector3,e=new o.Vector3,n=new o.Plane,r=new o.Line3;return function(o,i){const{radius:s,center:a}=o,{a:c,b:u,c:l}=i;if(r.start=c,r.end=u,r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;if(r.start=c,r.end=l,r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;if(r.start=u,r.end=l,r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;const d=i.getPlane(n);if(Math.abs(d.distanceToPoint(a))<=s){const t=d.projectPoint(a,e);if(i.containsPoint(t))return!0}return!1}}();function D(t){return Math.abs(t)<1e-15}class z extends o.Triangle{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new o.Vector3)),this.satBounds=new Array(4).fill().map((()=>new P)),this.points=[this.a,this.b,this.c],this.sphere=new o.Sphere,this.plane=new o.Plane,this.needsUpdate=!0}intersectsSphere(t){return V(t,this)}update(){const t=this.a,e=this.b,n=this.c,o=this.points,r=this.satAxes,i=this.satBounds,s=r[0],a=i[0];this.getNormal(s),a.setFromPoints(s,o);const c=r[1],u=i[1];c.subVectors(t,e),u.setFromPoints(c,o);const l=r[2],d=i[2];l.subVectors(e,n),d.setFromPoints(l,o);const f=r[3],h=i[3];f.subVectors(n,t),h.setFromPoints(f,o),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}z.prototype.closestPointToSegment=function(){const t=new o.Vector3,e=new o.Vector3,n=new o.Line3;return function(o,r=null,i=null){const{start:s,end:a}=o,c=this.points;let u,l=1/0;for(let s=0;s<3;s++){const a=(s+1)%3;n.start.copy(c[s]),n.end.copy(c[a]),F(n,o,t,e),u=t.distanceToSquared(e),u<l&&(l=u,r&&r.copy(t),i&&i.copy(e))}return this.closestPointToPoint(s,t),u=s.distanceToSquared(t),u<l&&(l=u,r&&r.copy(t),i&&i.copy(s)),this.closestPointToPoint(a,t),u=a.distanceToSquared(t),u<l&&(l=u,r&&r.copy(t),i&&i.copy(a)),Math.sqrt(l)}}(),z.prototype.intersectsTriangle=function(){const t=new z,e=new Array(3),n=new Array(3),r=new P,i=new P,s=new o.Vector3,a=new o.Vector3,c=new o.Vector3,u=new o.Vector3,l=new o.Line3,d=new o.Line3,f=new o.Line3;return function(o,h=null,p=!1){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const m=this.plane,y=o.plane;if(Math.abs(m.normal.dot(y.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;n[0]=o.a,n[1]=o.b,n[2]=o.c;for(let e=0;e<4;e++){const o=t[e],i=a[e];if(r.setFromPoints(i,n),o.isSeparated(r))return!1}const c=o.satBounds,u=o.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=c[t],o=u[t];if(r.setFromPoints(o,e),n.isSeparated(r))return!1}for(let t=0;t<4;t++){const o=a[t];for(let t=0;t<4;t++){const a=u[t];if(s.crossVectors(o,a),r.setFromPoints(s,e),i.setFromPoints(s,n),r.isSeparated(i))return!1}}return h&&(p||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),h.start.set(0,0,0),h.end.set(0,0,0)),!0}{const t=this.points;let e=!1,n=0;for(let o=0;o<3;o++){const r=t[o],i=t[(o+1)%3];l.start.copy(r),l.end.copy(i),l.delta(a);const s=e?d.start:d.end,c=D(y.distanceToPoint(r));if(D(y.normal.dot(a))&&c){d.copy(l),n=2;break}if((y.intersectLine(l,s)||c)&&!D(s.distanceTo(i))){if(n++,e)break;e=!0}}if(1===n&&o.containsPoint(d.end))return h&&(h.start.copy(d.end),h.end.copy(d.end)),!0;if(2!==n)return!1;const r=o.points;let i=!1,s=0;for(let t=0;t<3;t++){const e=r[t],n=r[(t+1)%3];l.start.copy(e),l.end.copy(n),l.delta(c);const o=i?f.start:f.end,a=D(m.distanceToPoint(e));if(D(m.normal.dot(c))&&a){f.copy(l),s=2;break}if((m.intersectLine(l,o)||a)&&!D(o.distanceTo(n))){if(s++,i)break;i=!0}}if(1===s&&this.containsPoint(f.end))return h&&(h.start.copy(f.end),h.end.copy(f.end)),!0;if(2!==s)return!1;if(d.delta(a),f.delta(c),a.dot(c)<0){let t=f.start;f.start=f.end,f.end=t}const p=d.start.dot(a),x=d.end.dot(a),g=f.start.dot(a),b=f.end.dot(a);return(p===b||g===x||x<g!=p<b)&&(h&&(u.subVectors(d.start,f.start),u.dot(a)>0?h.start.copy(d.start):h.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(a)<0?h.end.copy(d.end):h.end.copy(f.end)),!0)}}}(),z.prototype.distanceToPoint=function(){const t=new o.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),z.prototype.distanceToTriangle=function(){const t=new o.Vector3,e=new o.Vector3,n=["a","b","c"],r=new o.Line3,i=new o.Line3;return function(o,s=null,a=null){const c=s||a?r:null;if(this.intersectsTriangle(o,c))return(s||a)&&(s&&c.getCenter(s),a&&c.getCenter(a)),0;let u=1/0;for(let e=0;e<3;e++){let r;const i=n[e],c=o[i];this.closestPointToPoint(c,t),r=c.distanceToSquared(t),r<u&&(u=r,s&&s.copy(t),a&&a.copy(c));const l=this[i];o.closestPointToPoint(l,t),r=l.distanceToSquared(t),r<u&&(u=r,s&&s.copy(l),a&&a.copy(t))}for(let c=0;c<3;c++){const l=n[c],d=n[(c+1)%3];r.set(this[l],this[d]);for(let c=0;c<3;c++){const l=n[c],d=n[(c+1)%3];i.set(o[l],o[d]),F(r,i,t,e);const f=t.distanceToSquared(e);f<u&&(u=f,s&&s.copy(t),a&&a.copy(e))}}return Math.sqrt(u)}}();class N{constructor(t,e,n){this.isOrientedBox=!0,this.min=new o.Vector3,this.max=new o.Vector3,this.matrix=new o.Matrix4,this.invMatrix=new o.Matrix4,this.points=new Array(8).fill().map((()=>new o.Vector3)),this.satAxes=new Array(3).fill().map((()=>new o.Vector3)),this.satBounds=new Array(3).fill().map((()=>new P)),this.alignedSatBounds=new Array(3).fill().map((()=>new P)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}N.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,o=this.points;for(let r=0;r<=1;r++)for(let i=0;i<=1;i++)for(let s=0;s<=1;s++){const a=o[1*r|2*i|4*s];a.x=r?n.x:e.x,a.y=i?n.y:e.y,a.z=s?n.z:e.z,a.applyMatrix4(t)}const r=this.satBounds,i=this.satAxes,s=o[0];for(let t=0;t<3;t++){const e=i[t],n=r[t],a=o[1<<t];e.subVectors(s,a),n.setFromPoints(e,o)}const a=this.alignedSatBounds;a[0].setFromPointsField(o,"x"),a[1].setFromPointsField(o,"y"),a[2].setFromPointsField(o,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},N.prototype.intersectsBox=function(){const t=new P;return function(e){this.needsUpdate&&this.update();const n=e.min,o=e.max,r=this.satBounds,i=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=o.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=o.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=o.z,s[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const o=i[n],s=r[n];if(t.setFromBox(o,e),s.isSeparated(t))return!1}return!0}}(),N.prototype.intersectsTriangle=function(){const t=new z,e=new Array(3),n=new P,r=new P,i=new o.Vector3;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const s=this.satBounds,a=this.satAxes;e[0]=o.a,e[1]=o.b,e[2]=o.c;for(let t=0;t<3;t++){const o=s[t],r=a[t];if(n.setFromPoints(r,e),o.isSeparated(n))return!1}const c=o.satBounds,u=o.satAxes,l=this.points;for(let t=0;t<3;t++){const e=c[t],o=u[t];if(n.setFromPoints(o,l),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const o=a[t];for(let t=0;t<4;t++){const s=u[t];if(i.crossVectors(o,s),n.setFromPoints(i,e),r.setFromPoints(i,l),n.isSeparated(r))return!1}}return!0}}(),N.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},N.prototype.distanceToPoint=function(){const t=new o.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),N.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new o.Line3)),n=new Array(12).fill().map((()=>new o.Line3)),r=new o.Vector3,i=new o.Vector3;return function(o,s=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(a||c)&&(o.getCenter(i),this.closestPointToPoint(i,r),o.closestPointToPoint(r,i),a&&a.copy(r),c&&c.copy(i)),0;const u=s*s,l=o.min,d=o.max,f=this.points;let h=1/0;for(let t=0;t<8;t++){const e=f[t];i.copy(e).clamp(l,d);const n=e.distanceToSquared(i);if(n<h&&(h=n,a&&a.copy(e),c&&c.copy(i),n<u))return Math.sqrt(n)}let p=0;for(let o=0;o<3;o++)for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){const s=(o+1)%3,a=(o+2)%3,c=1<<o|r<<s|i<<a,u=f[r<<s|i<<a],h=f[c];e[p].set(u,h);const m=t[o],y=t[s],x=t[a],g=n[p],b=g.start,v=g.end;b[m]=l[m],b[y]=r?l[y]:d[y],b[x]=i?l[x]:d[y],v[m]=d[m],v[y]=r?l[y]:d[y],v[x]=i?l[x]:d[y],p++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){i.x=t?d.x:l.x,i.y=e?d.y:l.y,i.z=n?d.z:l.z,this.closestPointToPoint(i,r);const o=i.distanceToSquared(r);if(o<h&&(h=o,a&&a.copy(r),c&&c.copy(i),o<u))return Math.sqrt(o)}for(let t=0;t<12;t++){const o=e[t];for(let t=0;t<12;t++){const e=n[t];F(o,e,r,i);const s=r.distanceToSquared(i);if(s<h&&(h=s,a&&a.copy(r),c&&c.copy(i),s<u))return Math.sqrt(s)}}return Math.sqrt(h)}}();const U=new o.Vector3,E=new o.Vector3,_=new o.Vector3,k=new o.Vector2,H=new o.Vector2,R=new o.Vector2,q=new o.Vector3;function C(t,e,n,r,i){const s=3*r,a=t.index.getX(s),c=t.index.getX(s+1),u=t.index.getX(s+2),l=function(t,e,n,r,i,s,a){U.fromBufferAttribute(e,r),E.fromBufferAttribute(e,i),_.fromBufferAttribute(e,s);const c=function(t,e,n,r,i,s){let a;return a=s===o.BackSide?t.intersectTriangle(r,n,e,!0,i):t.intersectTriangle(e,n,r,s!==o.DoubleSide,i),null===a?null:{distance:t.origin.distanceTo(i),point:i.clone()}}(t,U,E,_,q,a);if(c){n&&(k.fromBufferAttribute(n,r),H.fromBufferAttribute(n,i),R.fromBufferAttribute(n,s),c.uv=o.Triangle.getUV(q,U,E,_,k,H,R,new o.Vector2));const t={a:r,b:i,c:s,normal:new o.Vector3,materialIndex:0};o.Triangle.getNormal(U,E,_,t.normal),c.face=t,c.faceIndex=r}return c}(n,t.attributes.position,t.attributes.uv,a,c,u,e);return l?(l.faceIndex=r,i&&i.push(l),l):null}function G(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t.distance<n.near||t.distance>n.far?null:t)}function O(t,e,n,o){const r=t.a,i=t.b,s=t.c;let a=e,c=e+1,u=e+2;n&&(a=n.getX(e),c=n.getX(e+1),u=n.getX(e+2)),r.x=o.getX(a),r.y=o.getY(a),r.z=o.getZ(a),i.x=o.getX(c),i.y=o.getY(c),i.z=o.getZ(c),s.x=o.getX(u),s.y=o.getY(u),s.z=o.getZ(u)}function L(t,e,n,o,r,i,s){const a=n.index,c=n.attributes.position;for(let n=t,u=e+t;n<u;n++)if(O(s,3*n,a,c),s.needsUpdate=!0,o(s,n,r,i))return!0;return!1}const W=new o.Vector3,X=new o.Vector3,Y=new o.Vector3,j=new o.Vector2,Z=new o.Vector2,$=new o.Vector2;function J(t,e,n,r){const i=e.getIndex().array,s=e.getAttribute("position"),a=e.getAttribute("uv"),c=i[3*n],u=i[3*n+1],l=i[3*n+2];W.fromBufferAttribute(s,c),X.fromBufferAttribute(s,u),Y.fromBufferAttribute(s,l);let d=0;const f=e.groups,h=3*n;for(let t=0,e=f.length;t<e;t++){const e=f[t],{start:n,count:o}=e;if(h>=n&&h<n+o){d=e.materialIndex;break}}let p=null;return a&&(j.fromBufferAttribute(a,c),Z.fromBufferAttribute(a,u),$.fromBufferAttribute(a,l),p=r&&r.uv?r.uv:new o.Vector2,o.Triangle.getUV(t,W,X,Y,j,Z,$,p)),r?(r.face||(r.face={}),r.face.a=c,r.face.b=u,r.face.c=l,r.face.materialIndex=d,r.face.normal||(r.face.normal=new o.Vector3),o.Triangle.getNormal(W,X,Y,r.face.normal),p&&(r.uv=p),r):{face:{a:c,b:u,c:l,materialIndex:d,normal:o.Triangle.getNormal(W,X,Y,new o.Vector3)},uv:p}}class K{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function Q(t,e){return 65535===e[t+15]}function tt(t,e){return e[t+6]}function et(t,e){return e[t+14]}function nt(t){return t+8}function ot(t,e){return e[t+6]}function rt(t,e){return e[t+7]}const it=new o.Box3,st=new o.Vector3,at=["x","y","z"];function ct(t,e,n,o,r){let i=2*t,s=mt,a=yt,c=xt;if(Q(i,a))!function(t,e,n,o,r,i){for(let s=o,a=o+r;s<a;s++)C(t,e,n,s,i)}(e,n,o,tt(t,c),et(i,a),r);else{const i=nt(t);ft(i,s,o,st)&&ct(i,e,n,o,r);const a=ot(t,c);ft(a,s,o,st)&&ct(a,e,n,o,r)}}function ut(t,e,n,o){let r=2*t,i=mt,s=yt,a=xt;if(Q(r,s))return function(t,e,n,o,r){let i=1/0,s=null;for(let a=o,c=o+r;a<c;a++){const o=C(t,e,n,a);o&&o.distance<i&&(s=o,i=o.distance)}return s}(e,n,o,tt(t,a),et(r,s));{const r=rt(t,a),s=at[r],c=o.direction[s]>=0;let u,l;c?(u=nt(t),l=ot(t,a)):(u=ot(t,a),l=nt(t));const d=ft(u,i,o,st)?ut(u,e,n,o):null;if(d){const t=d.point[s];if(c?t<=i[l+r]:t>=i[l+r+3])return d}const f=ft(l,i,o,st)?ut(l,e,n,o):null;return d&&f?d.distance<=f.distance?d:f:d||f||null}}const lt=function(){let t,e;const n=[],r=new K((()=>new o.Box3));return function(...o){t=r.getPrimitive(),e=r.getPrimitive(),n.push(t,e);const s=i(...o);r.releasePrimitive(t),r.releasePrimitive(e),n.pop(),n.pop();const a=n.length;return a>0&&(e=n[a-1],t=n[a-2]),s};function i(n,o,r,s,a=null,c=0,l=0){function d(t){let e=2*t,n=yt,o=xt;for(;!Q(e,n);)e=2*(t=nt(t));return tt(t,o)}function f(t){let e=2*t,n=yt,o=xt;for(;!Q(e,n);)e=2*(t=ot(t,o));return tt(t,o)+et(e,n)}let h=2*n,p=mt,m=yt,x=xt;if(Q(h,m)){const e=tt(n,x),o=et(h,m);return y(n,p,t),s(e,o,!1,l,c+n,t)}{const h=nt(n),g=ot(n,x);let b,v,w,B,T=h,A=g;if(a&&(w=t,B=e,y(T,p,w),y(A,p,B),b=a(w),v=a(B),v<b)){T=g,A=h;const t=b;b=v,v=t,w=B}w||(w=t,y(T,p,w));const M=r(w,Q(2*T,m),b,l+1,c+T);let I;if(M===u){const t=d(T);I=s(t,f(T)-t,!0,l+1,c+T,w)}else I=M&&i(T,o,r,s,a,c,l+1);if(I)return!0;B=e,y(A,p,B);const P=r(B,Q(2*A,m),v,l+1,c+A);let S;if(P===u){const t=d(A);S=s(t,f(A)-t,!0,l+1,c+A,B)}else S=P&&i(A,o,r,s,a,c,l+1);return!!S}}}(),dt=function(){const t=new z,e=new z,n=new o.Matrix4,r=new N,i=new N;return function o(s,a,c,u,l=null){let d=2*s,f=mt,h=yt,p=xt;if(null===l&&(c.boundingBox||c.computeBoundingBox(),r.set(c.boundingBox.min,c.boundingBox.max,u),l=r),!Q(d,h)){const t=s+8,e=p[s+6];return y(t,f,it),l.intersectsBox(it)&&o(t,a,c,u,l)?!0:(y(e,f,it),!(!l.intersectsBox(it)||!o(e,a,c,u,l)))}{const o=a,r=o.index,l=o.attributes.position,m=c.index,x=c.attributes.position,g=tt(s,p),b=et(d,h);if(n.copy(u).invert(),c.boundsTree)return y(s,f,i),i.matrix.copy(n),i.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:t=>i.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(u),t.b.applyMatrix4(u),t.c.applyMatrix4(u),t.needsUpdate=!0;for(let n=3*g,o=3*(b+g);n<o;n+=3)if(O(e,n,r,l),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}});for(let o=3*g,i=b+3*g;o<i;o+=3){O(t,o,r,l),t.a.applyMatrix4(n),t.b.applyMatrix4(n),t.c.applyMatrix4(n),t.needsUpdate=!0;for(let n=0,o=m.count;n<o;n+=3)if(O(e,n,m,x),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function ft(t,e,n,o){return y(t,e,it),n.intersectBox(it,o)}const ht=[];let pt,mt,yt,xt;function gt(t){pt&&ht.push(pt),pt=t,mt=new Float32Array(t),yt=new Uint16Array(t),xt=new Uint32Array(t)}function bt(){pt=null,mt=null,yt=null,xt=null,ht.length&&gt(ht.pop())}const vt=Symbol("skip tree generation"),wt=new o.Box3,Bt=new o.Box3,Tt=new o.Matrix4,At=new N,Mt=new N,It=new o.Vector3,Pt=new o.Vector3,St=new o.Vector3,Ft=new o.Vector3,Vt=new o.Vector3,Dt=new o.Box3,zt=new K((()=>new z));class Nt{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),Nt.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,o=t._roots,r=n.getIndex();let i;return i=e.cloneBuffers?{roots:o.map((t=>t.slice())),index:r.array.slice()}:{roots:o,index:r.array},i}static deserialize(t,e,n={}){if("boolean"==typeof n)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),Nt.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});n={setIndex:!0,...n};const{index:r,roots:i}=t,s=new Nt(e,{...n,[vt]:!0});if(s._roots=i,n.setIndex){const n=e.getIndex();if(null===n){const n=new o.BufferAttribute(t.index,1,!1);e.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return s}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:r,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[vt]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[vt]||(this._roots=function(t,e){const n=function(t,e){function n(t){V&&V(t/D)}function a(e,o,c,p=null,V=0){if(!z&&V>=y&&(z=!0,P&&(console.warn(`MeshBVH: Max depth of ${y} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),c<=S||V>=y)return n(o+c),e.offset=o,e.count=c,e;const D=function(t,e,n,o,a,c){let u=-1,f=0;if(c===r)u=x(e),-1!==u&&(f=(e[u]+e[u+3])/2);else if(c===i)u=x(t),-1!==u&&(f=function(t,e,n,o){let r=0;for(let i=e,s=e+n;i<s;i++)r+=t[6*i+2*o];return r/n}(n,o,a,u));else if(c===s){const r=w(t);let i=l*a;const s=6*o,c=6*(o+a);for(let t=0;t<3;t++){const o=e[t],h=(e[t+3]-o)/T;if(a<8){const e=[...M];e.length=a;let o=0;for(let r=s;r<c;r+=6,o++){const i=e[o];i.candidate=n[r+2*t],i.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:c}=i;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;v(r,n,s)}e.sort(A);let h=a;for(let t=0;t<h;t++){const n=e[t];for(;t+1<h&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),h--}for(let o=s;o<c;o+=6){const r=n[o+2*t];for(let t=0;t<h;t++){const i=e[t];r>=i.candidate?v(o,n,i.rightCacheBounds):(v(o,n,i.leftCacheBounds),i.count++)}}for(let n=0;n<h;n++){const o=e[n],s=o.count,c=a-o.count,h=o.leftCacheBounds,p=o.rightCacheBounds;let m=0;0!==s&&(m=w(h)/r);let y=0;0!==c&&(y=w(p)/r);const x=d+l*(m*s+y*c);x<i&&(u=t,i=x,f=o.candidate)}}else{for(let t=0;t<T;t++){const e=M[t];e.count=0,e.candidate=o+h+t*h;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=s;e<c;e+=6){let r=~~((n[e+2*t]-o)/h);r>=T&&(r=31);const i=M[r];i.count++,v(e,n,i.bounds)}const e=M[31];g(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=M[t],n=M[t+1];b(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let p=0;for(let e=0;e<31;e++){const n=M[e],o=n.count,s=n.bounds,c=M[e+1].rightCacheBounds;0!==o&&(0===p?g(s,I):b(s,I,I)),p+=o;let h=0,m=0;0!==p&&(h=w(I)/r);const y=a-p;0!==y&&(m=w(c)/r);const x=d+l*(h*p+m*y);x<i&&(u=t,i=x,f=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:u,pos:f}}(e.boundingData,p,f,o,c,F);if(-1===D.axis)return n(o+c),e.offset=o,e.count=c,e;const N=function(t,e,n,o,r){let i=n,s=n+o-1;const a=r.pos,c=2*r.axis;for(;;){for(;i<=s&&e[6*i+c]<a;)i++;for(;i<=s&&e[6*s+c]>=a;)s--;if(!(i<s))return i;for(let n=0;n<3;n++){let o=t[3*i+n];t[3*i+n]=t[3*s+n],t[3*s+n]=o;let r=e[6*i+2*n+0];e[6*i+2*n+0]=e[6*s+2*n+0],e[6*s+2*n+0]=r;let a=e[6*i+2*n+1];e[6*i+2*n+1]=e[6*s+2*n+1],e[6*s+2*n+1]=a}i++,s--}}(h,f,o,c,D);if(N===o||N===o+c)n(o+c),e.offset=o,e.count=c;else{e.splitAxis=D.axis;const t=new m,n=o,r=N-o;e.left=t,t.boundingData=new Float32Array(6),B(f,n,r,t.boundingData,u),a(t,n,r,u,V+1);const i=new m,s=N,l=c-r;e.right=i,i.boundingData=new Float32Array(6),B(f,s,l,i.boundingData,u),a(i,s,l,u,V+1)}return e}!function(t,e){if(!t.index){const n=t.attributes.position.count,r=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;i=n>65535?new Uint32Array(new r(4*n)):new Uint16Array(new r(2*n)),t.setIndex(new o.BufferAttribute(i,1));for(let t=0;t<n;t++)i[t]=t}}(t,e);const c=new Float32Array(6),u=new Float32Array(6),f=function(t,e){const n=t.attributes.position,o=t.index.array,r=o.length/3,i=new Float32Array(6*r),s=n.normalized,a=n.array,c=n.offset||0;let u=3;n.isInterleavedBufferAttribute&&(u=n.data.stride);const l=["getX","getY","getZ"];for(let t=0;t<r;t++){const r=3*t,d=6*t;let f,h,m;s?(f=o[r+0],h=o[r+1],m=o[r+2]):(f=o[r+0]*u+c,h=o[r+1]*u+c,m=o[r+2]*u+c);for(let t=0;t<3;t++){let o,r,c;s?(o=n[l[t]](f),r=n[l[t]](h),c=n[l[t]](m)):(o=a[f+t],r=a[h+t],c=a[m+t]);let u=o;r<u&&(u=r),c<u&&(u=c);let y=o;r>y&&(y=r),c>y&&(y=c);const x=(y-u)/2,g=2*t;i[d+g+0]=u+x,i[d+g+1]=x+(Math.abs(u)+x)*p,u<e[t]&&(e[t]=u),y>e[t+3]&&(e[t+3]=y)}}return i}(t,c),h=t.index.array,y=e.maxDepth,P=e.verbose,S=e.maxLeafTris,F=e.strategy,V=e.onProgress,D=t.index.count/3;let z=!1;const N=[],U=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],n=new Set;for(const e of t.groups)n.add(e.start),n.add(e.start+e.count);const o=Array.from(n.values()).sort(((t,e)=>t-e));for(let t=0;t<o.length-1;t++){const n=o[t],r=o[t+1];e.push({offset:n/3,count:(r-n)/3})}return e}(t);if(1===U.length){const t=U[0],e=new m;e.boundingData=c,function(t,e,n,o){let r=1/0,i=1/0,s=1/0,a=-1/0,c=-1/0,u=-1/0;for(let o=6*e,l=6*(e+n);o<l;o+=6){const e=t[o+0];e<r&&(r=e),e>a&&(a=e);const n=t[o+2];n<i&&(i=n),n>c&&(c=n);const l=t[o+4];l<s&&(s=l),l>u&&(u=l)}o[0]=r,o[1]=i,o[2]=s,o[3]=a,o[4]=c,o[5]=u}(f,t.offset,t.count,u),a(e,t.offset,t.count,u),N.push(e)}else for(let t of U){const e=new m;e.boundingData=new Float32Array(6),B(f,t.offset,t.count,e.boundingData,u),a(e,t.offset,t.count,u),N.push(e)}return N}(t,e);let a,c,u;const y=[],P=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<n.length;t++){const e=n[t];let o=S(e);const r=new P(f*o);a=new Float32Array(r),c=new Uint32Array(r),u=new Uint16Array(r),F(0,e),y.push(r)}return y;function S(t){return t.count?1:1+S(t.left)+S(t.right)}function F(t,e){const n=t/4,o=t/2,r=!!e.count,i=e.boundingData;for(let t=0;t<6;t++)a[n+t]=i[t];if(r){const r=e.offset,i=e.count;return c[n+6]=r,u[o+14]=i,u[o+15]=h,t+f}{const o=e.left,r=e.right,i=e.splitAxis;let s;if(s=F(t+f,o),s/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return c[n+6]=s/4,s=F(s,r),c[n+7]=i,s}}}(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new o.Box3))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,o=e.attributes.position;let r,i,s,a,c=0;const u=this._roots;for(let t=0,e=u.length;t<e;t++)r=u[t],i=new Uint32Array(r),s=new Uint16Array(r),a=new Float32Array(r),l(0,c),c+=r.byteLength;function l(e,r,c=!1){const u=2*e;if(s[u+15]===h){const t=i[e+6];let r=1/0,c=1/0,l=1/0,d=-1/0,f=-1/0,h=-1/0;for(let e=3*t,i=3*(t+s[u+14]);e<i;e++){const t=n[e],i=o.getX(t),s=o.getY(t),a=o.getZ(t);i<r&&(r=i),i>d&&(d=i),s<c&&(c=s),s>f&&(f=s),a<l&&(l=a),a>h&&(h=a)}return(a[e+0]!==r||a[e+1]!==c||a[e+2]!==l||a[e+3]!==d||a[e+4]!==f||a[e+5]!==h)&&(a[e+0]=r,a[e+1]=c,a[e+2]=l,a[e+3]=d,a[e+4]=f,a[e+5]=h,!0)}{const n=e+8,o=i[e+6],s=n+r,u=o+r;let d=c,f=!1,h=!1;t?d||(f=t.has(s),h=t.has(u),d=!f&&!h):(f=!0,h=!0);const p=d||h;let m=!1;(d||f)&&(m=l(n,r,d));let y=!1;p&&(y=l(o,r,d));const x=m||y;if(x)for(let t=0;t<3;t++){const r=n+t,i=o+t,s=a[r],c=a[r+3],u=a[i],l=a[i+3];a[e+t]=s<u?s:u,a[e+t+3]=c>l?c:l}return x}}}traverse(t,e=0){const n=this._roots[e],o=new Uint32Array(n),r=new Uint16Array(n);!function e(i,s=0){const a=2*i,c=r[a+15]===h;if(c){const e=o[i+6],u=r[a+14];t(s,c,new Float32Array(n,4*i,6),e,u)}else{const r=i+8,a=o[i+6],u=o[i+7];t(s,c,new Float32Array(n,4*i,6),u)||(e(r,s+1),e(a,s+1))}}(0)}raycast(t,e=o.FrontSide){const n=this._roots,r=this.geometry,i=[],s=e.isMaterial,a=Array.isArray(e),c=r.groups,u=s?e.side:e;for(let o=0,s=n.length;o<s;o++){const s=a?e[c[o].materialIndex].side:u,l=i.length;if(gt(n[o]),ct(0,r,s,t,i),bt(),a){const t=c[o].materialIndex;for(let e=l,n=i.length;e<n;e++)i[e].face.materialIndex=t}}return i}raycastFirst(t,e=o.FrontSide){const n=this._roots,r=this.geometry,i=e.isMaterial,s=Array.isArray(e);let a=null;const c=r.groups,u=i?e.side:e;for(let o=0,i=n.length;o<i;o++){const i=s?e[c[o].materialIndex].side:u;gt(n[o]);const l=ut(0,r,i,t);bt(),null!=l&&(null==a||l.distance<a.distance)&&(a=l,s&&(l.face.materialIndex=c[o].materialIndex))}return a}intersectsGeometry(t,e){const n=this.geometry;let o=!1;for(const r of this._roots)if(gt(r),o=dt(0,n,t,e),bt(),o)break;return o}shapecast(t,e,n){const o=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,n,o,r)=>{const i=3*n;return t(e,i,i+1,i+2,o,r)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=zt.getPrimitive();let{boundsTraverseOrder:i,intersectsBounds:s,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const t=a;a=(e,n,i,s,a)=>!!t(e,n,i,s,a)||L(e,n,o,c,i,s,r)}else a||(a=c?(t,e,n,i)=>L(t,e,o,c,n,i,r):(t,e,n)=>n);let u=!1,l=0;for(const t of this._roots){if(gt(t),u=lt(0,o,s,a,i,l),bt(),u)break;l+=t.byteLength}return zt.releasePrimitive(r),u}bvhcast(t,e,n){let{intersectsRanges:o,intersectsTriangles:r}=n;const i=this.geometry.index,s=this.geometry.attributes.position,a=t.geometry.index,c=t.geometry.attributes.position;Tt.copy(e).invert();const u=zt.getPrimitive(),l=zt.getPrimitive();if(r){function f(t,n,o,d,f,h,p,m){for(let y=o,x=o+d;y<x;y++){O(l,3*y,a,c),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let e=t,o=t+n;e<o;e++)if(O(u,3*e,i,s),u.needsUpdate=!0,r(u,l,e,y,f,h,p,m))return!0}return!1}if(o){const h=o;o=function(t,e,n,o,r,i,s,a){return!!h(t,e,n,o,r,i,s,a)||f(t,e,n,o,r,i,s,a)}}else o=f}t.getBoundingBox(Bt),Bt.applyMatrix4(e);const d=this.shapecast({intersectsBounds:t=>Bt.intersectsBox(t),intersectsRange:(e,n,r,i,s,a)=>(wt.copy(a),wt.applyMatrix4(Tt),t.shapecast({intersectsBounds:t=>wt.intersectsBox(t),intersectsRange:(t,r,a,c,u)=>o(e,n,t,r,i,s,c,u)}))});return zt.releasePrimitive(u),zt.releasePrimitive(l),d}intersectsBox(t,e){return At.set(t.min,t.max,e),At.needsUpdate=!0,this.shapecast({intersectsBounds:t=>At.intersectsBox(t),intersectsTriangle:t=>At.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},o={},r=0,i=1/0){t.boundingBox||t.computeBoundingBox(),At.set(t.boundingBox.min,t.boundingBox.max,e),At.needsUpdate=!0;const s=this.geometry,a=s.attributes.position,c=s.index,u=t.attributes.position,l=t.index,d=zt.getPrimitive(),f=zt.getPrimitive();let h=Pt,p=St,m=null,y=null;o&&(m=Ft,y=Vt);let x=1/0,g=null,b=null;return Tt.copy(e).invert(),Mt.matrix.copy(Tt),this.shapecast({boundsTraverseOrder:t=>At.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<i&&(e&&(Mt.min.copy(t.min),Mt.max.copy(t.max),Mt.needsUpdate=!0),!0),intersectsRange:(n,o)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>Mt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<x&&n<i,intersectsRange:(t,i)=>{for(let s=3*t,v=3*(t+i);s<v;s+=3){O(f,s,l,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let t=3*n,e=3*(n+o);t<e;t+=3){O(d,t,c,a),d.needsUpdate=!0;const e=d.distanceToTriangle(f,h,m);if(e<x&&(p.copy(h),y&&y.copy(m),x=e,g=t/3,b=s/3),e<r)return!0}}}});for(let t=0,i=l?l.count:u.count;t<i;t+=3){O(f,t,l,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let e=3*n,i=3*(n+o);e<i;e+=3){O(d,e,c,a),d.needsUpdate=!0;const n=d.distanceToTriangle(f,h,m);if(n<x&&(p.copy(h),y&&y.copy(m),x=n,g=e/3,b=t/3),n<r)return!0}}}}),zt.releasePrimitive(d),zt.releasePrimitive(f),x===1/0?null:(n.point?n.point.copy(p):n.point=p.clone(),n.distance=x,n.faceIndex=g,o&&(o.point?o.point.copy(y):o.point=y.clone(),o.point.applyMatrix4(Tt),p.applyMatrix4(Tt),o.distance=p.sub(o.point).length(),o.faceIndex=b),n)}closestPointToPoint(t,e={},n=0,o=1/0){const r=n*n,i=o*o;let s=1/0,a=null;if(this.shapecast({boundsTraverseOrder:e=>(It.copy(t).clamp(e.min,e.max),It.distanceToSquared(t)),intersectsBounds:(t,e,n)=>n<s&&n<i,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,It);const o=t.distanceToSquared(It);return o<s&&(Pt.copy(It),s=o,a=n),o<r}}),s===1/0)return null;const c=Math.sqrt(s);return e.point?e.point.copy(Pt):e.point=Pt.clone(),e.distance=c,e.faceIndex=a,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach((e=>{y(0,new Float32Array(e),Dt),t.union(Dt)})),t}}const Ut=new o.Box3;class Et extends o.Object3D{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,n=10,r=0){super(),this.material=e,this.geometry=new o.BufferGeometry,this.name="MeshBVHRootVisualizer",this.depth=n,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=r}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,n=this._group;if(t.dispose(),this.visible=!1,e){const r=this.depth-1,i=this.displayParents;let s=0;e.traverse(((t,e)=>{if(t===r||e)return s++,!0;i&&s++}),n);let a=0;const c=new Float32Array(24*s);let u,l;e.traverse(((t,e,n)=>{const o=t===r||e;if(o||i){y(0,n,Ut);const{min:t,max:e}=Ut;for(let n=-1;n<=1;n+=2){const o=n<0?t.x:e.x;for(let n=-1;n<=1;n+=2){const r=n<0?t.y:e.y;for(let n=-1;n<=1;n+=2){const i=n<0?t.z:e.z;c[a+0]=o,c[a+1]=r,c[a+2]=i,a+=3}}}return o}}),n),l=this.displayEdges?new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),u=c.length>65535?new Uint32Array(l.length*s):new Uint16Array(l.length*s);const d=l.length;for(let t=0;t<s;t++){const e=8*t,n=t*d;for(let t=0;t<d;t++)u[n+t]=e+l[t]}t.setIndex(new o.BufferAttribute(u,1,!1)),t.setAttribute("position",new o.BufferAttribute(c,3,!1)),this.visible=!0}}}class _t extends o.Group{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const n=new o.LineBasicMaterial({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),r=new o.MeshBasicMaterial({color:65416,transparent:!0,opacity:.3,depthWrite:!1});r.color=n.color,this.edgeMaterial=n,this.meshMaterial=r,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;){const t=this._roots.pop();t.geometry.dispose(),this.remove(t)}for(let t=0;t<e;t++){if(t>=this._roots.length){const e=new Et(this.mesh,this.edgeMaterial,this.depth,t);this.add(e),this._roots.push(e)}const e=this._roots[t];e.depth=this.depth,e.mesh=this.mesh,e.displayParents=this.displayParents,e.displayEdges=this.displayEdges,e.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,e.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new _t(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].geometry.dispose()}}const kt=new o.Box3,Ht=new o.Box3,Rt=new o.Vector3;function qt(t){switch(typeof t){case"number":return 8;case"string":return 2*t.length;case"boolean":return 4;default:return 0}}function Ct(t){return t._roots.map(((e,n)=>function(t,e){const n={nodeCount:0,leafNodeCount:0,depth:{min:1/0,max:-1/0},tris:{min:1/0,max:-1/0},splits:[0,0,0],surfaceAreaScore:0};return t.traverse(((t,e,o,r,i)=>{const s=o[3]-o[0],a=o[4]-o[1],c=o[5]-o[2],u=2*(s*a+a*c+c*s);n.nodeCount++,e?(n.leafNodeCount++,n.depth.min=Math.min(t,n.depth.min),n.depth.max=Math.max(t,n.depth.max),n.tris.min=Math.min(i,n.tris.min),n.tris.max=Math.max(i,n.tris.max),n.surfaceAreaScore+=u*l*i):(n.splits[r]++,n.surfaceAreaScore+=u*d)}),e),n.tris.min===1/0&&(n.tris.min=0,n.tris.max=0),n.depth.min===1/0&&(n.depth.min=0,n.depth.max=0),n}(t,n)))}function Gt(t){const e=new Set,n=[t];let o=0;for(;n.length;){const t=n.pop();if(!e.has(t)){e.add(t);for(let e in t){if(!t.hasOwnProperty(e))continue;o+=qt(e);const r=t[e];!r||"object"!=typeof r&&"function"!=typeof r?o+=qt(r):/(Uint|Int|Float)(8|16|32)Array/.test(r.constructor.name)||r instanceof ArrayBuffer?o+=r.byteLength:n.push(r)}}}return o}function Ot(t){const e=t.geometry,n=[],o=e.index,r=e.getAttribute("position");let i=!0;return t.traverse(((t,e,s,a,c)=>{const u={depth:t,isLeaf:e,boundingData:s,offset:a,count:c};n[t]=u,y(0,s,kt);const l=n[t-1];if(e)for(let t=3*a,e=3*(a+c);t<e;t+=3){const e=o.getX(t),n=o.getX(t+1),s=o.getX(t+2);let a;Rt.fromBufferAttribute(r,e),a=kt.containsPoint(Rt),Rt.fromBufferAttribute(r,n),a=a&&kt.containsPoint(Rt),Rt.fromBufferAttribute(r,s),a=a&&kt.containsPoint(Rt),console.assert(a,"Leaf bounds does not fully contain triangle."),i=i&&a}if(l){y(0,s,Ht);const t=Ht.containsBox(kt);console.assert(t,"Parent bounds does not fully contain child."),i=i&&t}})),i}function Lt(t){const e=[];return t.traverse(((t,n,r,i,s)=>{const a={bounds:y(0,r,new o.Box3)};n?(a.count=s,a.offset=i):(a.left=null,a.right=null),e[t]=a;const c=e[t-1];c&&(null===c.left?c.left=a:c.right=a)})),e[0]}const Wt=new o.Ray,Xt=new o.Matrix4,Yt=o.Mesh.prototype.raycast;function jt(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;Xt.copy(this.matrixWorld).invert(),Wt.copy(t.ray).applyMatrix4(Xt);const n=this.geometry.boundsTree;if(!0===t.firstHitOnly){const o=G(n.raycastFirst(Wt,this.material),this,t);o&&e.push(o)}else{const o=n.raycast(Wt,this.material);for(let n=0,r=o.length;n<r;n++){const r=G(o[n],this,t);r&&e.push(r)}}}else Yt.call(this,t,e)}function Zt(t){return this.boundsTree=new Nt(this,t),this.boundsTree}function $t(){this.boundsTree=null}function Jt(t){switch(t){case 1:return o.RedIntegerFormat;case 2:return o.RGIntegerFormat;case 3:case 4:return o.RGBAIntegerFormat}}class Kt extends o.DataTexture{constructor(){super(),this.minFilter=o.NearestFilter,this.magFilter=o.NearestFilter,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(t){const e=this.overrideItemSize,n=t.itemSize,r=t.count;if(null!==e){if(n*r%e!=0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");t.itemSize=e,t.count=r*n/e}const i=t.itemSize,s=t.count,a=t.normalized,c=t.array.constructor,u=c.BYTES_PER_ELEMENT;let l,d,f,h,p=this._forcedType,m=i;if(null===p)switch(c){case Float32Array:p=o.FloatType;break;case Uint8Array:case Uint16Array:case Uint32Array:p=o.UnsignedIntType;break;case Int8Array:case Int16Array:case Int32Array:p=o.IntType}let y=function(t){switch(t){case 1:return"R";case 2:return"RG";case 3:case 4:return"RGBA"}throw new Error}(i);switch(p){case o.FloatType:f=1,d=function(t){switch(t){case 1:return o.RedFormat;case 2:return o.RGFormat;case 3:case 4:return o.RGBAFormat}}(i),a&&1===u?(h=c,y+="8",c===Uint8Array?l=o.UnsignedByteType:(l=o.ByteType,y+="_SNORM")):(h=Float32Array,y+="32F",l=o.FloatType);break;case o.IntType:y+=8*u+"I",f=a?Math.pow(2,8*c.BYTES_PER_ELEMENT-1):1,d=Jt(i),1===u?(h=Int8Array,l=o.ByteType):2===u?(h=Int16Array,l=o.ShortType):(h=Int32Array,l=o.IntType);break;case o.UnsignedIntType:y+=8*u+"UI",f=a?Math.pow(2,8*c.BYTES_PER_ELEMENT-1):1,d=Jt(i),1===u?(h=Uint8Array,l=o.UnsignedByteType):2===u?(h=Uint16Array,l=o.UnsignedShortType):(h=Uint32Array,l=o.UnsignedIntType)}3!==m||d!==o.RGBAFormat&&d!==o.RGBAIntegerFormat||(m=4);const x=Math.ceil(Math.sqrt(s)),g=new h(m*x*x),b=t.normalized;t.normalized=!1;for(let e=0;e<s;e++){const n=m*e;g[n]=t.getX(e)/f,i>=2&&(g[n+1]=t.getY(e)/f),i>=3&&(g[n+2]=t.getZ(e)/f,4===m&&(g[n+3]=1)),i>=4&&(g[n+3]=t.getW(e)/f)}t.normalized=b,this.internalFormat=y,this.format=d,this.type=l,this.image.width=x,this.image.height=x,this.image.data=g,this.needsUpdate=!0,this.dispose(),t.itemSize=n,t.count=r}}class Qt extends Kt{constructor(){super(),this._forcedType=o.UnsignedIntType}}class te extends Kt{constructor(){super(),this._forcedType=o.IntType}}class ee extends Kt{constructor(){super(),this._forcedType=o.FloatType}}class ne{constructor(){this.autoDispose=!0,this.index=new Qt,this.position=new ee,this.bvhBounds=new o.DataTexture,this.bvhContents=new o.DataTexture,this.index.overrideItemSize=3}updateFrom(t){const{geometry:e}=t;!function(t,e,n){const r=t._roots;if(1!==r.length)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const i=r[0],s=new Uint16Array(i),a=new Uint32Array(i),c=new Float32Array(i),u=i.byteLength/f,l=2*Math.ceil(Math.sqrt(u/2)),d=new Float32Array(4*l*l),h=Math.ceil(Math.sqrt(u)),p=new Uint32Array(2*h*h);for(let t=0;t<u;t++){const e=t*f/4,n=2*e,o=e;for(let e=0;e<3;e++)d[8*t+0+e]=c[o+0+e],d[8*t+4+e]=c[o+3+e];if(Q(n,s)){const o=et(n,s),r=tt(e,a),i=4294901760|o;p[2*t+0]=i,p[2*t+1]=r}else{const n=4*ot(e,a)/f,o=rt(e,a);p[2*t+0]=o,p[2*t+1]=n}}e.image.data=d,e.image.width=l,e.image.height=l,e.format=o.RGBAFormat,e.type=o.FloatType,e.internalFormat="RGBA32F",e.minFilter=o.NearestFilter,e.magFilter=o.NearestFilter,e.generateMipmaps=!1,e.needsUpdate=!0,e.dispose(),n.image.data=p,n.image.width=h,n.image.height=h,n.format=o.RGIntegerFormat,n.type=o.UnsignedIntType,n.internalFormat="RG32UI",n.minFilter=o.NearestFilter,n.magFilter=o.NearestFilter,n.generateMipmaps=!1,n.needsUpdate=!0,n.dispose()}(t,this.bvhBounds,this.bvhContents),this.index.updateFrom(e.index),this.position.updateFrom(e.attributes.position)}dispose(){const{index:t,position:e,bvhBounds:n,bvhContents:o}=this;t&&t.dispose(),e&&e.dispose(),n&&n.dispose(),o&&o.dispose()}}const oe="\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n",re="\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\n// Raycasting\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tfloat dist = max( t0, 0.0 );\n\n\treturn t1 >= dist ? dist : INFINITY;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\n\tinout float minDistance,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\n\n}\n\nbool bvhIntersectFirstHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = 1e20;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n",ie="\n\nfloat dot2( in vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\tBVH bvh, vec3 point, uint offset, uint count, float closestDistanceSquared,\n\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord, out float side, out vec3 outPoint\n) {\n\n\tbool found = false;\n\tuvec3 localIndices;\n\tvec3 localBarycoord;\n\tvec3 localNormal;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\nfloat bvhClosestPointToPoint(\n\tBVH bvh, vec3 point,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh, point, offset, count, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n",se=new o.Vector3,ae=new o.Vector3,ce=new o.Vector3,ue=new o.Vector4,le=new o.Vector3,de=new o.Vector3,fe=new o.Vector4,he=new o.Vector4,pe=new o.Matrix4,me=new o.Matrix4;function ye(t,e){if(!t&&!e)return;const n=t.count===e.count,o=t.normalized===e.normalized,r=t.array.constructor===e.array.constructor,i=t.itemSize===e.itemSize;if(!(n&&o&&r&&i))throw new Error}function xe(t,e=null){const n=t.array.constructor,r=t.normalized,i=t.itemSize,s=null===e?t.count:e;return new o.BufferAttribute(new n(i*s),i,r)}function ge(t,e,n=0){if(t.isInterleavedBufferAttribute){const o=t.itemSize;for(let r=0,i=t.count;r<i;r++){const i=r+n;e.setX(i,t.getX(r)),o>=2&&e.setY(i,t.getY(r)),o>=3&&e.setZ(i,t.getZ(r)),o>=4&&e.setW(i,t.getW(r))}}else{const o=e.array,r=o.constructor,i=o.BYTES_PER_ELEMENT*t.itemSize*n;new r(o.buffer,i,t.array.length).set(t.array)}}function be(t,e,n){const o=t.elements,r=e.elements;for(let t=0,e=r.length;t<e;t++)o[t]+=r[t]*n}function ve(t,e,n){const o=t.skeleton,r=t.geometry,i=o.bones,s=o.boneInverses;fe.fromBufferAttribute(r.attributes.skinIndex,e),he.fromBufferAttribute(r.attributes.skinWeight,e),pe.elements.fill(0);for(let t=0;t<4;t++){const e=he.getComponent(t);if(0!==e){const n=fe.getComponent(t);me.multiplyMatrices(i[n].matrixWorld,s[n]),be(pe,me,e)}}return pe.multiply(t.bindMatrix).premultiply(t.bindMatrixInverse),n.transformDirection(pe),n}function we(t,e,n,o,r){le.set(0,0,0);for(let i=0,s=t.length;i<s;i++){const s=e[i],a=t[i];0!==s&&(de.fromBufferAttribute(a,o),n?le.addScaledVector(de,s):le.addScaledVector(de.sub(r),s))}r.add(le)}class Be{constructor(t){this.matrixWorld=new o.Matrix4,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=t,this.update()}update(){const t=this.mesh,e=t.geometry,n=t.skeleton,o=(e.index?e.index.count:e.attributes.position.count)/3;if(this.matrixWorld.copy(t.matrixWorld),this.geometryHash=e.attributes.position.version,this.primitiveCount=o,n){n.boneTexture||n.computeBoneTexture(),n.update();const t=n.boneMatrices;this.boneMatrices&&this.boneMatrices.length===t.length?this.boneMatrices.set(t):this.boneMatrices=t.slice()}else this.boneMatrices=null}didChange(){const t=this.mesh,e=t.geometry,n=(e.index?e.index.count:e.attributes.position.count)/3;return!(this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===e.attributes.position.version&&function(t,e){if(null===t||null===e)return t===e;if(t.length!==e.length)return!1;for(let n=0,o=t.length;n<o;n++)if(t[n]!==e[n])return!1;return!0}(t.skeleton&&t.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===n)}}class Te{constructor(t){Array.isArray(t)||(t=[t]);const e=[];t.forEach((t=>{t.traverseVisible((t=>{t.isMesh&&e.push(t)}))})),this.meshes=e,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(e.length).fill().map((()=>new o.BufferGeometry)),this._diffMap=new WeakMap}getMaterials(){const t=[];return this.meshes.forEach((e=>{Array.isArray(e.material)?t.push(...e.material):t.push(e.material)})),t}generate(t=new o.BufferGeometry){let e=[];const{meshes:n,useGroups:r,_intermediateGeometry:i,_diffMap:s}=this;for(let t=0,o=n.length;t<o;t++){const o=n[t],r=i[t],a=s.get(o);!a||a.didChange(o)?(this._convertToStaticGeometry(o,r),e.push(!1),a?a.update():s.set(o,new Be(o))):e.push(!0)}!function(t,e={useGroups:!1,updateIndex:!1,skipAttributes:[]},n=new o.BufferGeometry){const r=null!==t[0].index,{useGroups:i=!1,updateIndex:s=!1,skipAttributes:a=[]}=e,c=new Set(Object.keys(t[0].attributes)),u={};let l=0;n.clearGroups();for(let e=0;e<t.length;++e){const o=t[e];let s=0;if(r!==(null!==o.index))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const t in o.attributes){if(!c.has(t))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.');void 0===u[t]&&(u[t]=[]),u[t].push(o.attributes[t]),s++}if(s!==c.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(i){let t;if(r)t=o.index.count;else{if(void 0===o.attributes.position)throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");t=o.attributes.position.count}n.addGroup(l,t,e),l+=t}}if(r){let e=!1;if(!n.index){let r=0;for(let e=0;e<t.length;++e)r+=t[e].index.count;n.setIndex(new o.BufferAttribute(new Uint32Array(r),1,!1)),e=!0}if(s||e){const e=n.index;let o=0,r=0;for(let n=0;n<t.length;++n){const i=t[n],s=i.index;if(!0!==a[n])for(let t=0;t<s.count;++t)e.setX(o,s.getX(t)+r),o++;r+=i.attributes.position.count}}}for(const t in u){const e=u[t];if(!(t in n.attributes)){let o=0;for(const t in e)o+=e[t].count;n.setAttribute(t,xe(u[t][0],o))}const o=n.attributes[t];let r=0;for(let t=0,n=e.length;t<n;t++){const n=e[t];!0!==a[t]&&ge(n,o,r),r+=n.count}}}(i,{useGroups:r,skipAttributes:e},t);for(const e in t.attributes)t.attributes[e].needsUpdate=!0;return t}_convertToStaticGeometry(t,e=new o.BufferGeometry){const n=t.geometry,r=this.applyWorldTransforms,i=this.attributes.includes("normal"),s=this.attributes.includes("tangent"),a=n.attributes,c=e.attributes;e.index||(e.index=n.index),c.position||e.setAttribute("position",xe(a.position)),i&&!c.normal&&a.normal&&e.setAttribute("normal",xe(a.normal)),s&&!c.tangent&&a.tangent&&e.setAttribute("tangent",xe(a.tangent)),ye(n.index,e.index),ye(a.position,c.position),i&&ye(a.normal,c.normal),s&&ye(a.tangent,c.tangent);const u=a.position,l=i?a.normal:null,d=s?a.tangent:null,f=n.morphAttributes.position,h=n.morphAttributes.normal,p=n.morphAttributes.tangent,m=n.morphTargetsRelative,y=t.morphTargetInfluences,x=new o.Matrix3;x.getNormalMatrix(t.matrixWorld);for(let e=0,n=a.position.count;e<n;e++)se.fromBufferAttribute(u,e),l&&ae.fromBufferAttribute(l,e),d&&(ue.fromBufferAttribute(d,e),ce.fromBufferAttribute(d,e)),y&&(f&&we(f,y,m,e,se),h&&we(h,y,m,e,ae),p&&we(p,y,m,e,ce)),t.isSkinnedMesh&&(t.boneTransform(e,se),l&&ve(t,e,ae),d&&ve(t,e,ce)),r&&se.applyMatrix4(t.matrixWorld),c.position.setXYZ(e,se.x,se.y,se.z),l&&(r&&ae.applyNormalMatrix(x),c.normal.setXYZ(e,ae.x,ae.y,ae.z)),d&&(r&&ce.transformDirection(t.matrixWorld),c.tangent.setXYZW(e,ce.x,ce.y,ce.z,ue.w));for(const t in this.attributes){const n=this.attributes[t];"position"!==n&&"tangent"!==n&&"normal"!==n&&n in a&&(c[n]||e.setAttribute(n,xe(a[n])),ye(a[n],c[n]),ge(a[n],c[n]))}return e}}}}]);